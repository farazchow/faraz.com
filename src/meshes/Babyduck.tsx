/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/models/babyduck.glb -t -T 
Files: public/models/babyduck.glb [2.37MB] > C:\Users\notfa\Desktop\PersonalProjects\Portfolio Website\babyduck-transformed.glb [80.08KB] (97%)
*/

import * as THREE from 'three'
import React, { useContext, useEffect, useState } from 'react'
import { useFrame, useGraph } from '@react-three/fiber'
import { useGLTF, useAnimations, Outlines } from '@react-three/drei'
import { type GLTF, SkeletonUtils } from 'three-stdlib'
import type { ShaderProps } from '../utils/ShaderAbstract'
import CustomShaderMaterial from 'three-custom-shader-material/vanilla'
import { NavContext } from '../components/NavContext'
// import { useControls } from 'leva'

type ActionName = 'ArmatureAction.001'

interface GLTFAction extends THREE.AnimationClip {
  name: ActionName
}

type GLTFResult = GLTF & {
  nodes: {
    Cube002: THREE.SkinnedMesh
    Cube002_1: THREE.SkinnedMesh
    Bone: THREE.Bone
    Bone003: THREE.Bone
  }
  materials: {
    ['Material.002']: THREE.MeshStandardMaterial
    ['Material.003']: THREE.MeshStandardMaterial
  }
  animations: GLTFAction[]
}

function Babyduck(props: ShaderProps) {
  const { navState, setNavState } = useContext(NavContext);
  const [inspect, setInspect] = useState(false);
  const group = React.useRef<THREE.Group>(null!);
  const [hovered, setHover] = useState(false);

  // Materials - Initialize with placeholder
  const [BeakMat, setBeakMat] = useState<THREE.Material | CustomShaderMaterial>(() => new THREE.MeshStandardMaterial());
  const [BodyMat, setBodyMat] = useState<THREE.Material | CustomShaderMaterial>(() => new THREE.MeshStandardMaterial());

  const { scene, animations } = useGLTF('/models/babyduck-transformed.glb');
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = (useGraph(clone) as unknown) as GLTFResult ;
  const { actions, names } = useAnimations(animations, group);
  const baseBeakMat = materials['Material.002'];
  const baseBodyMat = materials['Material.003'];

  const mesh1 = React.useRef<THREE.SkinnedMesh>(null!);
  const mesh2 = React.useRef<THREE.SkinnedMesh>(null!);

  // Animation Time offset
  // eslint-disable-next-line react-hooks/purity
  const timeOffset =  Math.random() * 2 * Math.PI;

  // Play Default Animations
  useEffect(() => {
    actions[names[0]]?.reset().play();
  }, [actions, names])

  // const options = useControls(props.shader.getLevaControls());

  // Materials
  useEffect(() => {
    if (baseBeakMat && baseBeakMat.color) {
      const clonedMat = baseBeakMat.clone();
      clonedMat.wireframe = props.wireframe ?? false;
      clonedMat.flatShading = props.flatShading ?? false;
      // eslint-disable-next-line react-hooks/set-state-in-effect
      setBeakMat(props.shader.CreateMaterial(clonedMat));
    }
  }, [baseBeakMat, baseBeakMat.map, props.wireframe, props.flatShading, props.shader]);

  useEffect(() => {
    if (baseBodyMat && baseBodyMat.map) {
      const clonedMat = baseBodyMat.clone();
      clonedMat.wireframe = props.wireframe ?? false;
      clonedMat.flatShading = props.flatShading ?? false;
      // eslint-disable-next-line react-hooks/set-state-in-effect
      setBodyMat(props.shader.CreateMaterial(clonedMat));
    }
  }, [baseBodyMat, baseBodyMat.map, props.wireframe, props.flatShading, props.shader]);

  // Inspect View
  useEffect(() => {
    if (inspect) {
      group.current.rotateX(-42 * Math.PI/180);
      const closeFactor = .6;
      group.current.position.set(-2 - (2 * closeFactor), 3 * closeFactor, 2 * closeFactor);
    } else {
      group.current.position.set(props.position?.x ?? 0, props.position?.y ?? 0, props.position?.z ?? 0);
      group.current.rotation.set(0, -Math.PI/4, 0);
    }
  }, [inspect, group, props.position]);

  // Animation Loop and shader uniforms update
  useFrame((state) => {
    // Return early if they aren't setup;
    if (!(BeakMat instanceof CustomShaderMaterial) || 
      !(BodyMat instanceof CustomShaderMaterial) || 
      !mesh1.current || 
      !mesh2.current) {
      return;
    }

    props.shader.UpdateUniforms((mesh1.current.material as CustomShaderMaterial), state);
    props.shader.UpdateUniforms((mesh2.current.material as CustomShaderMaterial), state);

    if (!inspect) {
      group.current.position.y = Math.sin(state.clock.elapsedTime/2 + timeOffset) / 16 + .05;
      group.current.position.x += Math.sin(state.clock.elapsedTime/2 + timeOffset) / 2000;
      group.current.position.z += Math.sin(state.clock.elapsedTime/2 + timeOffset) / 2000;
    } else {
      group.current.rotateY(Math.sin(state.clock.elapsedTime/2 + timeOffset) / 100);
    }
  });

  function onClick() {
    const state = {
        objID: props.objID ?? 0,
    };
    setNavState(state);
    setInspect(true);
  }

  function clickOff() {
    const state = {
        objID: 0,
    };
    setNavState(state);
    setInspect(false);
  }

  return (
    <group ref={group} 
      {...props} 
      scale={1/3}
      rotation={[0, -Math.PI/4, 0]}
      dispose={null}
    >
      <group name="Scene">
        <group name="Armature">
          <primitive object={nodes.Bone} />
          <primitive object={nodes.Bone003} />
        </group>
        <group name="baby_duck"
          onPointerOver={() => setHover(!inspect && true)}
          onPointerOut={() => setHover(!inspect && false)}
          onClick={(e) => {
            if (hovered) {
              e.stopPropagation();
              onClick()
            }
          }}
          onPointerMissed={(e) => {
            if (inspect) {
              e.stopPropagation();
              clickOff();
            }
          }}
        >
          <skinnedMesh name="Beak" ref={mesh1} geometry={nodes.Cube002.geometry} material={BeakMat} skeleton={nodes.Cube002.skeleton} />
          <skinnedMesh name="MainBody" ref={mesh2} geometry={nodes.Cube002_1.geometry} material={BodyMat} skeleton={nodes.Cube002_1.skeleton} >
            {hovered && <Outlines thickness={3} color="#ffffff" />}
          </skinnedMesh>
        </group>
      </group>
    </group>
  )
}

useGLTF.preload('/models/babyduck-transformed.glb');
export default Babyduck;