/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/models/babyduck.glb -t -T 
Files: public/models/babyduck.glb [2.37MB] > C:\Users\notfa\Desktop\PersonalProjects\Portfolio Website\babyduck-transformed.glb [80.08KB] (97%)
*/

import * as THREE from 'three'
import React, { useEffect, useMemo, useState } from 'react'
import { useFrame, useGraph } from '@react-three/fiber'
import { useGLTF, useAnimations, Outlines } from '@react-three/drei'
import { type GLTF, SkeletonUtils } from 'three-stdlib'
import type { ShaderProps } from '../utils/ShaderAbstract'
import type CustomShaderMaterial from 'three-custom-shader-material/vanilla'
import { useControls } from 'leva'

type ActionName = 'ArmatureAction.001'

interface GLTFAction extends THREE.AnimationClip {
  name: ActionName
}

type GLTFResult = GLTF & {
  nodes: {
    Cube002: THREE.SkinnedMesh
    Cube002_1: THREE.SkinnedMesh
    Bone: THREE.Bone
    Bone003: THREE.Bone
  }
  materials: {
    ['Material.002']: THREE.MeshStandardMaterial
    ['Material.003']: THREE.MeshStandardMaterial
  }
  animations: GLTFAction[]
}

function Babyduck(props: ShaderProps) {
  const group = React.useRef<THREE.Group>(null!);
  const [hovered, setHover] = useState(false);

  const { scene, animations } = useGLTF('/models/babyduck-transformed.glb');
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = (useGraph(clone) as unknown) as GLTFResult ;
  const { actions, names } = useAnimations(animations, group);

  const mesh1 = React.useRef<THREE.SkinnedMesh>(null!);
  const mesh2 = React.useRef<THREE.SkinnedMesh>(null!);

  // Play Default Animations
  useEffect(() => {
    actions[names[0]]?.reset().play();
  }, [actions, names])

  const options = useControls(props.shader.getLevaControls());

  // Materials
  const BeakMat = useMemo(() =>  
    {
      const base = materials['Material.002'];
      if (base && (base.map)) {
        return base;

        base.wireframe = props.wireframe ?? false;
        base.flatShading = props.flatShading ?? false;
        return props.shader.CreateMaterial(base);
      }
    }, [materials, props]
  );  
  const MainBodyMat = useMemo(() =>  
    {
      const base = materials['Material.003'];
      if (base && (base.map)) {
        return base; 
        
        base.wireframe = props.wireframe ?? false;
        base.flatShading = props.flatShading ?? false;
        return props.shader.CreateMaterial(base);
      }
    }, [materials, props]
  );

  // Animation Loop and shader uniforms update
  useFrame((state, delta) => {
    // Return early if they aren't setup;
    if (!(BeakMat && MainBodyMat)) {
      return;
    }

    props.shader.UpdateUniforms((mesh1.current.material as CustomShaderMaterial), state, options);
    props.shader.UpdateUniforms((mesh2.current.material as CustomShaderMaterial), state, options);

    if (!hovered) {
      group.current.rotateY(delta);
    }
  });

  return (
    <group ref={group} 
      {...props} 
      dispose={null}
    >
      <group name="Scene">
        <group name="Armature">
          <primitive object={nodes.Bone} />
          <primitive object={nodes.Bone003} />
        </group>
        <group name="baby_duck"
          onPointerOver={() => setHover(true)}
          onPointerOut={() => setHover(false)}
          onPointerDown={() => {
            if (hovered) {
              console.log("Duck clicked");
            }
          }}
        >
          <skinnedMesh name="Beak" ref={mesh1} geometry={nodes.Cube002.geometry} material={BeakMat} skeleton={nodes.Cube002.skeleton} />
          <skinnedMesh name="MainBody" ref={mesh2} geometry={nodes.Cube002_1.geometry} material={MainBodyMat} skeleton={nodes.Cube002_1.skeleton} >
            {hovered && <Outlines thickness={3} color="white" />}
          </skinnedMesh>
        </group>
      </group>
    </group>
  )
}

useGLTF.preload('/models/babyduck-transformed.glb');
export default Babyduck;