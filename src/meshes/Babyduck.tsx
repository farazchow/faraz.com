/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/models/babyduck.glb -t -T 
Files: public/models/babyduck.glb [2.37MB] > C:\Users\notfa\Desktop\PersonalProjects\Portfolio Website\babyduck-transformed.glb [80.08KB] (97%)
*/

import * as THREE from 'three'
import React, { useContext, useEffect, useState } from 'react'
import { useFrame, useGraph, type ThreeEvent } from '@react-three/fiber'
import { useGLTF, useAnimations, Outlines } from '@react-three/drei'
import { type GLTF, SkeletonUtils } from 'three-stdlib'
import type { ShaderProps } from '../utils/ShaderAbstract'
import CustomShaderMaterial from 'three-custom-shader-material/vanilla'
import { NavContext } from '../components/NavContext'
import useInspectPosition from '../utils/useInspectPosition'
// import { useControls } from 'leva'

type ActionName = 'ArmatureAction.001'

interface GLTFAction extends THREE.AnimationClip {
  name: ActionName
}

type GLTFResult = GLTF & {
  nodes: {
    Cube002: THREE.SkinnedMesh
    Cube002_1: THREE.SkinnedMesh
    Bone: THREE.Bone
    Bone003: THREE.Bone
  }
  materials: {
    ['Material.002']: THREE.MeshStandardMaterial
    ['Material.003']: THREE.MeshStandardMaterial
  }
  animations: GLTFAction[]
}

function Babyduck(props: ShaderProps) {
  const { navState, setNavState } = useContext(NavContext);
  const inspectPosition = useInspectPosition(.5, -.6);

  const group = React.useRef<THREE.Group>(null!);
  const [hovered, setHover] = useState(false);

  // Materials - Initialize with placeholder
  const [BeakMat, setBeakMat] = useState<THREE.Material | CustomShaderMaterial>(() => new THREE.MeshStandardMaterial());
  const [BodyMat, setBodyMat] = useState<THREE.Material | CustomShaderMaterial>(() => new THREE.MeshStandardMaterial());

  const { scene, animations } = useGLTF('/models/babyduck-transformed.glb');
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = (useGraph(clone) as unknown) as GLTFResult ;
  const { actions, names } = useAnimations(animations, group);
  const baseBeakMat = materials['Material.002'];
  const baseBodyMat = materials['Material.003'];

  const mesh1 = React.useRef<THREE.SkinnedMesh>(null!);
  const mesh2 = React.useRef<THREE.SkinnedMesh>(null!);

  // Animation Time offset
  // eslint-disable-next-line react-hooks/purity
  const timeOffset =  Math.random() * 2 * Math.PI;

  // Play Default Animations
  useEffect(() => {
    actions[names[0]]?.reset().play();
  }, [actions, names])

  // const options = useControls(props.shader.getLevaControls());

  // Materials
  useEffect(() => {
    if (baseBeakMat && baseBeakMat.color) {
      const clonedMat = baseBeakMat.clone();
      clonedMat.wireframe = props.wireframe ?? false;
      clonedMat.flatShading = props.flatShading ?? false;
      setBeakMat(props.shader.CreateMaterial(clonedMat));
    }
  }, [baseBeakMat, baseBeakMat.map, props.wireframe, props.flatShading, props.shader]);

  useEffect(() => {
    if (baseBodyMat && baseBodyMat.map) {
      const clonedMat = baseBodyMat.clone();
      clonedMat.wireframe = props.wireframe ?? false;
      clonedMat.flatShading = props.flatShading ?? false;
      setBodyMat(props.shader.CreateMaterial(clonedMat));
    }
  }, [baseBodyMat, baseBodyMat.map, props.wireframe, props.flatShading, props.shader]);

  // Inspect View
  useEffect(() => {
    if (navState.objID === props.objID) {
      group.current.rotateX(-30 * Math.PI/180);
      group.current.position.set(inspectPosition[0], inspectPosition[1], inspectPosition[2]);
      group.current.scale.set(.3, .3, .3);
    } else {
      group.current.position.set(props.position?.x ?? 0, props.position?.y ?? 0, props.position?.z ?? 0);
      group.current.rotation.set(0, 0, 0);
      group.current.scale.set(1/3, 1/3, 1/3);
    }
  }, [group, props.position, inspectPosition, navState.objID, props.objID]);

  // Animation Loop and shader uniforms update
  useFrame((state) => {
    // Return early if they aren't setup;
    if (!(BeakMat instanceof CustomShaderMaterial) || 
      !(BodyMat instanceof CustomShaderMaterial) || 
      !mesh1.current || 
      !mesh2.current) {
      return;
    }

    props.shader.UpdateUniforms((mesh1.current.material as CustomShaderMaterial), state);
    props.shader.UpdateUniforms((mesh2.current.material as CustomShaderMaterial), state);

    if (navState.objID !== props.objID) {
      group.current.position.y = Math.sin(state.clock.elapsedTime/2 + timeOffset) / 16 + .075;
      group.current.position.x += Math.sin(state.clock.elapsedTime/2 + timeOffset) / 2000;
    } else {
      group.current.rotation.y += 0.005;
    }
  });

  function onClick(e: ThreeEvent<MouseEvent>) {
    if (!hovered || navState.objID !== 0) {
      return;
    }

    e.stopPropagation();
    const state = {
        objID: props.objID ?? 0,
    };
    setNavState(state);
  }

  function clickOff(e: MouseEvent) {
    if (navState.objID === props.objID) {
      e.stopPropagation();
      const state = {
          objID: 0,
      };
      setNavState(state);
    }

  }

  return (
    <group ref={group} 
      {...props} 
      scale={1/3}
      rotation={[0, 0, 0]}
      dispose={null}
    >
      <group name="Scene">
        <group name="Armature">
          <primitive object={nodes.Bone} />
          <primitive object={nodes.Bone003} />
        </group>
        <group name="baby_duck"
          onPointerOver={() => setHover(navState.objID === 0)}
          onPointerOut={() => setHover(false)}
          onClick={onClick}
          onPointerMissed={clickOff}
        >
          <skinnedMesh name="Beak" ref={mesh1} geometry={nodes.Cube002.geometry} material={BeakMat} skeleton={nodes.Cube002.skeleton} />
          <skinnedMesh name="MainBody" ref={mesh2} geometry={nodes.Cube002_1.geometry} material={BodyMat} skeleton={nodes.Cube002_1.skeleton} >
            {hovered && navState.objID === 0 && <Outlines thickness={3} color="#ffffff" />}
          </skinnedMesh>
        </group>
      </group>
    </group>
  )
}

useGLTF.preload('/models/babyduck-transformed.glb');
export default Babyduck;