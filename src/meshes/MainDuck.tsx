/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 ./public/models/duck.glb --transform -t 
Files: ./public/models/duck.glb [474.98KB] > C:\Users\notfa\Desktop\PersonalProjects\Portfolio Website\duck-transformed.glb [62.12KB] (87%)
*/

import * as THREE from 'three'
import React, { useContext, useEffect, useState } from 'react'
import { useFrame, useGraph, type ThreeEvent } from '@react-three/fiber'
import { useGLTF, useAnimations, Outlines } from '@react-three/drei'
import { type GLTF, SkeletonUtils } from 'three-stdlib'
import type { ShaderProps } from '../utils/ShaderAbstract'
import CustomShaderMaterial from 'three-custom-shader-material/vanilla'
import { NavContext } from '../components/NavContext'
import useInspectPosition from '../utils/useInspectPosition'

type ActionName = 'Idle' | 'Look Left' | 'Look Right'

interface GLTFAction extends THREE.AnimationClip {
  name: ActionName
}

type GLTFResult = GLTF & {
  nodes: {
    Duck: THREE.SkinnedMesh
    Bone: THREE.Bone
    Bone003: THREE.Bone
  }
  materials: {
    ['Material.001']: THREE.MeshStandardMaterial
  }
  animations: GLTFAction[]
}

export default function MainDuck(props: ShaderProps) {
  const { navState, setNavState } = useContext(NavContext);
  const inspectPosition = useInspectPosition(.5, -.5);

  const group = React.useRef<THREE.Group>(null!);
  const [hovered, setHover] = useState(false);
  const mesh = React.useRef<THREE.SkinnedMesh>(null!);

  const { scene, animations } = useGLTF('/models/duck-transformed.glb');
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = (useGraph(clone) as unknown) as GLTFResult;
  const baseMat = materials["Material.001"];
  const { actions, names } = useAnimations(animations, group);

  // Material
  const [mat, setMat] = useState<THREE.Material | CustomShaderMaterial>(() => new THREE.MeshStandardMaterial());
  useEffect(() => {
    if (baseMat && baseMat.map) {
      const clonedMat = baseMat.clone();
      clonedMat.wireframe = props.wireframe ?? false;
      clonedMat.flatShading = props.flatShading ?? false;
      // eslint-disable-next-line react-hooks/set-state-in-effect
      setMat(props.shader.CreateMaterial(clonedMat));
    }
  }, [baseMat, baseMat.map, props.wireframe, props.flatShading, props.shader]);

  // Play Idle animation
  useEffect(() => {
    actions["Idle"]?.reset().play();
  }, [actions, names]);

  // Update
  useFrame((state) => {
    // Return early if they aren't setup;
    if (!(mat instanceof CustomShaderMaterial) || !mesh.current) {
      return;
    }

    props.shader.UpdateUniforms((mesh.current.material as CustomShaderMaterial), state);

    if (navState.objID !== props.objID) {
      group.current.position.y = Math.sin(state.clock.elapsedTime/2) / 16 + .05;
      group.current.position.x += Math.sin(state.clock.elapsedTime/3) / 2000;
    } else {
      group.current.rotateY(Math.sin(state.clock.elapsedTime/2) / 100);
    }
  });

  // Inspect View
  useEffect(() => {
    if (navState.objID === props.objID) {
      group.current.rotateX(-30 * Math.PI/180);
      group.current.position.set(inspectPosition[0], inspectPosition[1], inspectPosition[2]);
      group.current.scale.set(.3, .3, .3);
    } else {
      group.current.scale.set(1/2, 1/2, 1/2);
      group.current.position.set(props.position?.x ?? 0, props.position?.y ?? 0, props.position?.z ?? 0);
      group.current.rotation.set(0, 0, 0);
    }
  }, [group, props.position, inspectPosition, navState.objID, props.objID]);


  function onClick(e : ThreeEvent<MouseEvent>) {
    if (hovered) {
      e.stopPropagation();
      const state = {
        objID: props.objID ?? 0,
      };
      setNavState(state);
    }
  }

  function clickOff(e: MouseEvent) {
    if (navState.objID === props.objID) {
      e.stopPropagation();
      const state = {
          objID: 0,
      };
      setNavState(state);
    }

  }

  return (
    <group 
      ref={group} 
      {...props} 
      dispose={null}
      scale={1/2}
      rotation={[0, 0, 0]}
    >
      <group name="Scene">
        <group name="Armature" position={[-2.03, 0, 0]}>
          <primitive object={nodes.Bone} />
          <primitive object={nodes.Bone003} />
        </group>
        <skinnedMesh 
          onPointerOver={() => setHover(navState.objID === 0)}
          onPointerOut={() => setHover(false)}
          onClick={onClick}
          onPointerMissed={clickOff}
          name="Duck" 
          ref={mesh} 
          geometry={nodes.Duck.geometry} 
          material={mat} 
          skeleton={nodes.Duck.skeleton} 
          position={[-2.03, 0, 0]} >
          {hovered && navState.objID === 0 && 
          <Outlines 
            thickness={3} 
            color="#ffffff" 
          />}
        </skinnedMesh>
      </group>
    </group>
  )
}

useGLTF.preload('/models/duck-transformed.glb')
