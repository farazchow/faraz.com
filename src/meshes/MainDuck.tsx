/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 ./public/models/duck.glb --transform -t 
Files: ./public/models/duck.glb [474.98KB] > C:\Users\notfa\Desktop\PersonalProjects\Portfolio Website\duck-transformed.glb [62.12KB] (87%)
*/

import * as THREE from 'three'
import React, { useContext, useEffect, useState } from 'react'
import { useFrame, useGraph } from '@react-three/fiber'
import { useGLTF, useAnimations, Outlines } from '@react-three/drei'
import { type GLTF, SkeletonUtils } from 'three-stdlib'
import type { ShaderProps } from '../utils/ShaderAbstract'
import CustomShaderMaterial from 'three-custom-shader-material/vanilla'
import { NavContext } from '../components/NavContext'

type ActionName = 'Idle' | 'Look Left' | 'Look Right'

interface GLTFAction extends THREE.AnimationClip {
  name: ActionName
}

type GLTFResult = GLTF & {
  nodes: {
    Duck: THREE.SkinnedMesh
    Bone: THREE.Bone
    Bone003: THREE.Bone
  }
  materials: {
    ['Material.001']: THREE.MeshStandardMaterial
  }
  animations: GLTFAction[]
}

export default function MainDuck(props: ShaderProps) {
  const { navState, setNavState } = useContext(NavContext);
  const [inspect, setInspect] = useState(false);

  const group = React.useRef<THREE.Group>(null!);
  const [hovered, setHover] = useState(false);
  const mesh = React.useRef<THREE.SkinnedMesh>(null!);

  const { scene, animations } = useGLTF('/models/duck-transformed.glb');
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = (useGraph(clone) as unknown) as GLTFResult;
  const baseMat = materials["Material.001"];
  const { actions, names } = useAnimations(animations, group);

  // Material
  const [mat, setMat] = useState<THREE.Material | CustomShaderMaterial>(() => new THREE.MeshStandardMaterial());
  useEffect(() => {
    if (baseMat && baseMat.map) {
      const clonedMat = baseMat.clone();
      clonedMat.wireframe = props.wireframe ?? false;
      clonedMat.flatShading = props.flatShading ?? false;
      // eslint-disable-next-line react-hooks/set-state-in-effect
      setMat(props.shader.CreateMaterial(clonedMat));
    }
  }, [baseMat, baseMat.map, props.wireframe, props.flatShading, props.shader]);

  // Play Idle animation
  useEffect(() => {
    actions["Idle"]?.reset().play();
  }, [actions, names]);

  // Update
  useFrame((state) => {
    // Return early if they aren't setup;
    if (!(mat instanceof CustomShaderMaterial) || !mesh.current) {
      return;
    }

    props.shader.UpdateUniforms((mesh.current.material as CustomShaderMaterial), state);

    if (!inspect) {
      group.current.position.y = Math.sin(state.clock.elapsedTime/2) / 16 + .05;
      group.current.position.x += Math.sin(state.clock.elapsedTime/3) / 2000;
      group.current.position.z += Math.sin(state.clock.elapsedTime/3) / 2000;
    } else {
      group.current.rotateY(Math.sin(state.clock.elapsedTime/2) / 100);
    }
  });

  // Inspect View
  useEffect(() => {
    if (inspect) {
      group.current.rotateX(-42 * Math.PI/180);
      const closeFactor = .6;
      group.current.position.set(-2 - (2 * closeFactor), 3 * closeFactor, 2 * closeFactor);
      group.current.scale.set(1/3, 1/3, 1/3);
    } else {
      group.current.position.set(props.position?.x ?? 0, props.position?.y ?? 0, props.position?.z ?? 0);
      group.current.rotation.set(0, -Math.PI/4, 0);
      group.current.scale.set(1/2, 1/2, 1/2);
    }
  }, [inspect, group, props.position]);

  function onClick() {
    const state = {
        objID: props.objID ?? 0,
    };
    setNavState(state);
    setInspect(true);
  }

  function clickOff() {
    const state = {
        objID: 0,
    };
    setNavState(state);
    setInspect(false);
  }

  return (
    <group 
      ref={group} 
      {...props} 
      dispose={null}
      scale={1/2}
      rotation={[0, -Math.PI/4, 0]}
    >
      <group name="Scene">
        <group name="Armature" position={[-2.03, 0, 0]}>
          <primitive object={nodes.Bone} />
          <primitive object={nodes.Bone003} />
        </group>
        <skinnedMesh 
          onPointerOver={() => setHover(true)}
          onPointerOut={() => setHover(false)}
          onClick={(e) => {
            if (hovered) {
              e.stopPropagation();
              onClick();
            }
          }}
          onPointerMissed={(e) => {
            if (inspect) {
              e.stopPropagation();
              clickOff();
            }
          }}
          name="Duck" 
          ref={mesh} 
          geometry={nodes.Duck.geometry} 
          material={mat} 
          skeleton={nodes.Duck.skeleton} 
          position={[-2.03, 0, 0]} >
          {hovered && <Outlines thickness={3} color="#ffffff" />}
        </skinnedMesh>
      </group>
    </group>
  )
}

useGLTF.preload('/models/duck-transformed.glb')
